// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

error IdenticalAddresses();
error ZeroAddress();
// error IndexOutOfBounds; // Remove this - implicit revert is sufficient


/**
 * @title MockUniswapV2Factory
 * @dev Mock implementation of Uniswap V2 Factory mimicking core logic for testing
 */
contract MockUniswapV2Factory {
    // Mapping from token0 to token1 to pair address
    mapping(address => mapping(address => address)) public getPair;

    // Array of all created pairs
    // Making this public automatically creates the allPairs(uint index) getter
    address[] public allPairs;

    // Event emitted when a pair is created
    event PairCreated(address indexed token0, address indexed token1, address pair, uint allPairsLength);

    /**
     * @dev Returns the number of pairs created by the factory.
     */
    function allPairsLength() external view returns (uint) {
        return allPairs.length;
    }

    /**
     * @dev Creates a pair for tokenA and tokenB if one doesn't exist yet.
     * Follows Uniswap V2 logic: sorts tokens, checks existence, calculates deterministic address.
     * @param tokenA The address of the first token.
     * @param tokenB The address of the second token.
     * @return pair The address of the pair contract (newly created or existing).
     */
    function createPair(address tokenA, address tokenB) external returns (address pair) {
        // --- Input Validation ---
        if (tokenA == tokenB) revert IdenticalAddresses();

        // --- Sorting Tokens (Mimics Uniswap V2 internal logic) ---
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

        // --- Zero Address Check (After sorting) ---
        if (token0 == address(0)) revert ZeroAddress();

        // --- Check if Pair Exists (Mimics Uniswap V2 logic) ---
        pair = getPair[token0][token1]; // Read existing pair address
        if (pair != address(0)) {
            // If pair already exists, return its address
            return pair;
        }

        // --- Deterministic Pair Address Calculation (Mocking CREATE2) ---
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        pair = address(uint160(uint(keccak256(abi.encodePacked(
                bytes1(0xff),
                address(this),
                salt,
                keccak256(abi.encodePacked("MockPairBytecode"))
            )))));

        // --- State Updates ---
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // Ensure getPair works regardless of order
        allPairs.push(pair);

        // --- Event Emission ---
        emit PairCreated(token0, token1, pair, allPairs.length);

        // Return the newly calculated pair address (already assigned to 'pair')
        // return pair; // Implicit return works as well
    }

    // REMOVED the explicit allPairs(uint index) function
    // It is automatically generated by `address[] public allPairs;`

    // --- Optional: Mock Fee Handling ---
    // ... (fee handling code remains the same if needed) ...
}